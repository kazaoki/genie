#!/usr/bin/env node


'use strict';

var opt = require('optimist');
var stringWidth = require('string-width');
var clc = require('cli-color');
var rl = require('readline').createInterface(process.stdin, process.stdout);

// .usage('Usage: $0 -x [num] -y [num]')
// .demand(['v'])
// .default({x:100, y:50, v:true})
// .boolean('v')
// .alias('v', 'verbose')
// .describe('v', 'show details')
// .options('f', {
// 	alias : 'file',
// 	default : '/etc/passwd',
// })
// .wrap(70)
var argv = opt.usage('Usage: genie|g [Commands] [Options]').options('mode', {
	alias: 'm',
	default: '',
	describe: '実行モードを指定可能'
}).options('config', {
	alias: 'c',
	default: 'config.js',
	describe: '設定ファイルを指定可能'
}).options('help', {
	alias: 'h',
	describe: '説明表示'
}).argv;

/**
 * demo
 * -------------------------------------------------------------------
 */
if (argv._.includes('demo')) {
	// メッセージBOX
	console.log();
	Message('サンプル：default', 'default');
	Message('サンプル：primary', 'primary');
	Message('サンプル：success', 'success');
	Message('サンプル：danger', 'danger');
	Message('サンプル：warning', 'warning');
	Message('サンプル：info', 'info');
	Message('改行込み、1ライン入れも可能。\ntest1\ntest2\ntest3', 'default', 1);

	// 入力BOX
	var input = Input('入力BOX（入力文字を発音しますのでご注意）：', 20);

	Message('入力された文字：' + input);

	// sayテスト
	// say($input);

	// エラー終了
	// throw('エラーテスト', '終了ステータス1で終わります');
}
/**
 * clean
 * -------------------------------------------------------------------
 */
else if (argv._.includes('clean')) {
		// オプション設定
		var argv = opt.usage('Usage: genie|g clean [Options]').options('locked', {
			alias: 'l',
			describe: '`locked`を含むDataVolumeも削除'
		}).argv;
		;
		if (argv.help) opt.showHelp();
	}
	/**
  * help
  * -------------------------------------------------------------------
  */
	else {
			console.error(opt.help() + '\n' + 'Commands:\n' + '  init    \n' + '  config  \n' + '  ls      \n' + '  up      \n' + '  down    \n' + '  update  \n' + '  cli     \n' + '  reject  \n' + '  clean   \n' + '  build   \n' + '  php     \n' + '  perl    \n' + '  ruby    \n' + '  mysql   \n' + '  psql    \n' + '  open    \n' + '  ngrok   \n' + '  logs    \n' + '  dlsync  \n' + '  httpd   \n' + '  spec    \n' + '  zap     \n' + '  demo     デモするよ！\n');
		}

'use strict';

/**
 * Message
 */

var _regenerator = require('babel-runtime/regenerator');

var _regenerator2 = _interopRequireDefault(_regenerator);

var _asyncToGenerator2 = require('babel-runtime/helpers/asyncToGenerator');

var _asyncToGenerator3 = _interopRequireDefault(_asyncToGenerator2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function Message(message) {
	var type = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'default';
	var line = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;

	// console.log(message)
	// console.log(type)
	// console.log(line)

	// var cls = clc.xterm(10).bgXterm(14);

	// console.log(clc.white.bgBlue.bold('                            '));

	// console.log(cls('ABC'));
	// process.stdout.write(clc.reset);
	// process.stdout.write(clc.erase.screen);
	// process.stdout.write(clc.erase.screenRight);
	// process.stdout.write(clc.move(-2, -2)); // Move cursors two columns and two rows back

	// process.stdout.write(clc.move.lines(2));
	// console.log(cls('123'));

	var indent = '  ';
	var line_color = clc.white;
	var fg_color = clc.white;
	if (type === 'primary') {
		line_color = clc.xterm(26);
		fg_color = clc.xterm(39);
	} else if (type === 'success') {
		line_color = clc.green;
		fg_color = clc.greenBright;
	} else if (type === 'danger') {
		line_color = clc.red;
		fg_color = clc.redBright;
	} else if (type === 'warning') {
		line_color = clc.yellow;
		fg_color = clc.yellowBright;
	} else if (type === 'info') {
		line_color = clc.whiteBright;
		fg_color = clc.whiteBright;
	}

	var messages = message.split(/[\r\n]+/);
	var length = 0;
	for (var i in messages) {
		var len = stringWidth(messages[i]);
		if (length < len) length = len;
	}
	length += 2;

	console.log(indent + line_color('┏') + line_color(Repeat('─', length)) + line_color('┓'));
	for (var i in messages) {
		if (line > 0 && line == i) {
			console.log(indent + line_color('┣') + line_color(Repeat('─', length)) + line_color('┫'));
		}
		console.log(indent + line_color('│') + fg_color(' ' + messages[i] + ' ') + Repeat(' ', length - 2 - stringWidth(messages[i])) + line_color('│'));
	}
	console.log(indent + line_color('┗') + line_color(Repeat('─', length)) + line_color('┛'));
}
function Repeat(string) {
	var times = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;

	var lump = '';
	if (times > 0) {
		for (var i = 0; i < times; i++) {
			lump += string;
		}
	}
	return lump;
}

/**
 * Input
 */
function Input(message) {
	var _this = this;

	var tail_space = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 20;

	var indent = '  ';
	message = '  ' + message + '  ';
	var len = stringWidth(message) + tail_space;
	var fg = clc.whiteBright.bgBlueBright;
	var bg = clc.bgBlue;
	console.log(indent + fg(Repeat(' ', len)) + '\n' + indent + fg(message + Repeat(' ', tail_space)) + '\n' + indent + fg(Repeat(' ', len)) + '\n' + indent + bg(Repeat(' ', len)));

	// var input = fs.readFileSync('/dev/stdin', 'utf8');
	// var input = '';
	// process.stdin.resume();
	// process.stdin.setEncoding('utf8');
	// process.stdin.on('data', function(chunk) {
	// 	input += chunk;
	// });
	// process.stdin.on('end', function() {
	// 	return input;
	// });

	// var f = async () => {
	// 	var ret = await () => {
	// 		const rl=require("readline").createInterface(process.stdin,process.stdout);
	// 		rl.on("line",function(str){
	// 			console.log("get:"+str);
	// 		});
	// 	}
	// };
	// f();

	// rl.moveCursor(process.stdin, 0,0)

	// (async function(){
	// 	// var str = await new Promise(res=>rl.once("line",res));
	// 	// console.log("getA:"+str);
	// 	// str = await new Promise(res=>rl.once("line",res));
	// 	// console.log("getB:"+str);
	// 	// str = await new Promise(res=>rl.once("line",res));
	// 	// console.log("getC:"+str);
	// 	// console.log("end");

	// 	//関数化
	// 	const gets=()=>new Promise(res=>rl.once("line",res))
	// 	var str = await gets();
	// 	console.log("getA:" + str);
	// 	str = await gets();
	// 	console.log("getB:" + str);
	// 	str = await gets();
	// 	console.log("getC:" + str);
	// 	console.log("end");

	// 	process.exit();
	// })();

	(0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee() {
		return _regenerator2.default.wrap(function _callee$(_context) {
			while (1) {
				switch (_context.prev = _context.next) {
					case 0:
						console.log('!!');

					case 1:
					case 'end':
						return _context.stop();
				}
			}
		}, _callee, _this);
	}))();
}